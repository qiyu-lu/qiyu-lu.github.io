---
title: "SLAM 算法阅读记录：Traj-LO"
date: 2025-08-12 
categories: [SLAM算法梳理]
tags: [SLAM, Traj-LO]
---

- 纯雷达slam，类似ct-icp的连续时间思想
- **项目地址**：[https://github.com/kevin2431/Traj-LO](https://github.com/kevin2431/Traj-LO)  
- **论文地址**：[https://ieeexplore.ieee.org/document/10387726](https://ieeexplore.ieee.org/document/10387726)

---

# 1. 代码阅读

## 1.1 主函数

**`run_trajlo.cpp`** 文件就是主节点，根据运行时输入的命令的参数 `argv[1]` 来获得配置文件的路径

### 1.1.1 配置类 `TrajConfig`

- 实例化一个 配置类 `traj::TrajConfig config;` 对象， 将命令行中的配置文件的路径传入这个类中：`config.load(config_path);`，功能就是读取配置文件中的参数的内容；

### 1.1.2 雷达里程计类 `TrajLOdometry`

- 实例化一个雷达里程计类对象指针 `traj::TrajLOdometry::Ptr trajLOdometry(new traj::TrajLOdometry(config));` ，采用传参构造，传入的配置类对象来获取配置文件中的部分需要的参数；

   ```cpp
   TrajLOdometry::TrajLOdometry(const TrajConfig& config)
      : config_(config), isFinish(false) {
   min_range_2_ = config.min_range * config.min_range;//设置点云的最小距离阈值（平方值）,过滤掉距离太近的激光点，避免自遮挡或噪声点
   converge_thresh_ = config.converge_thresh;//优化迭代的收敛判断阈值,当位姿增量小于此值时，认为优化收敛，停止迭代

   laser_data_queue.set_capacity(100);//设置激光雷达数据队列的最大容量

   init_interval_ = config.init_interval; //系统启动时的第一个时间窗口大小
   window_interval_ = config.seg_interval; //每个时间段的持续时间
   max_frames_ = config.seg_num; //滑动窗口中最多保留的帧数,控制内存使用和计算复杂度

   map_.reset(new MapManager(config.ds_size, config.voxel_size,
                              config.planer_thresh, config.max_voxel_num,
                              config.max_range));
   //ds_size：点云降采样网格大小; voxel_size：体素地图的体素边长; planer_thresh：平面拟合的阈值; 
   //max_voxel_num：地图中最大体素数量; max_range：激光雷达的最大有效距离

   // setup marginalization
   marg_H.setZero(POSE_SIZE, POSE_SIZE);
   marg_b.setZero(POSE_SIZE); //初始化边缘化的Hessian矩阵和梯度向量  //维度：POSE_SIZE = 6（3个旋转 + 3个平移）
   double init_pose_weight = config.init_pose_weight; 
   marg_H.diagonal().setConstant(init_pose_weight);
   //设置初始位姿的先验信息权重,为第一个位姿提供稳定性约束,权重越大，初始位姿越稳定
   }
   ```
### 1.1.3 数据载入类 `DataLoader`

- 实例化一个数据载入类指针对象为空指针： `traj::DataLoader::Ptr dataLoader = nullptr;` ;
- 然后通过配置文件中的雷达的类型：`config.type` 来根据不同的雷达的类型，来采用不同的字段读取点云；
- 当读取后如果 `DataLoader` 中的`tbb::concurrent_bounded_queue<Scan::Ptr> *laser_queue = nullptr;` 该指针非空指针，就将读取的点云数据利用对应的 `pub` 函数存入到这个指针中；
   该指针构造时是空指针，当用户点击可视化窗口的对应的数据集的相关按键时才会进行读取存储点云，不点击时不进行任何操作。
- 发布

### 1.1.4 可视化类 `Visualizer`

- 通过之前的三个类 `trajLOdometry, config, dataLoader` 来实例化一个可视化类指针，进行一些窗口的初始化操作；
- 主循环：`visualizer->mainLoop();`，其中 `{ drawPanel(); }// 绘制主要的控制面板和3D场景` 
   这部分中实现了点击对应的部分来设置代码中里程计中的一些标志位，启用里程计：`odometry->Start();`;
   并且还有上文中存储点云的空指针的赋值：`dataset->laser_queue = &odometry->laser_data_queue; `,此时点云开始发布到里程计的点云队列 `odometry->laser_data_queue` 中去.

## 1.2 里程计的启动函数 `void TrajLOdometry::Start()`

- 这里是一个lambda函数，死循环中执行着核心的功能；

### 1.2.1 点云分割

- 从之前从传感器中读取的点云数据队列 `laser_data_queue` 中 获取当前最新的点云数据 `curr_scan`，然后通过一个布尔值 `first_scan` 来判断是否是第一次扫描：

   如果是第一次扫描，这个初始分段点云的起止时间分别为：初始扫描的的开始时间戳 `last_begin_t_ns_ = curr_scan->timestamp;`、开始时间加上配置文件中的初始时间间隔`last_end_t_ns_ = last_begin_t_ns_ + init_interval_;`
- 调用 `void TrajLOdometry::PointCloudSegment(Scan::Ptr scan, Measurement::Ptr measure)` 函数，功能：

   将传入的扫描点云 `curr_scan` 中的点进行筛选时间在 `last_begin_t_ns_ ` 和 `last_end_t_ns_` 之间的，(之所以在代码中不考虑 `last_begin_t_ns_` 之后的，是因为代码的逻辑已经保证了不会有“过早”的点遗留，点云处理是单调时间递增的，数据的上游经过按照时间排序的处理，因此每个点的时间戳只会往后，不会出现“比 last_begin_t_ns_ 还早”的点。)
   
   如果点在时间段之间，就将点存入 `points_cache` 中，然后点超出了时间范围，就将 之前存的那个时间段的 `points_cache;` 存入 `measure`中，并设置对应的起止时间为对应的时间 `measure->tp = {last_begin_t_ns_, last_end_t_ns_};`；
   
   再将 `measure` 存入 `measure_cache` 中去，之后清空 `points_cache`，`measure`，并重设下一次的起止时间，下一次的开始时间是这一次的结束时间，下一次的结束时间是开始时间加上配置中的窗口时间间隔。

- 然后`measure_cache`存的一个一个`measure`就是不同时间段的点

### 1.2.2 计算时间插值因子

- 去掉一些坐标为`nan` 的点，筛选到雷达距离为配置文件中设置的距离的点，`len < min_range_2_`
- 从 `measure_cache` 弹出最新的测量点云 `measure` ，计算这一段点云每个点的时间在整个时间段的占比，即时间插值因子，
- 将符合条件的点以及对应的插值因子 `alpha` 存入 `points` 中 `points.emplace_back(Eigen::Vector4d(p.x, p.y, p.z, alpha));`

### 1.2.3 初始化地图

- 如果没有初始化地图，就对初始时间段的点云 `measure` 中提取的有效点`points`组织为体素网格结构，进行初始化地图
- 将当前帧的位姿状态存储在`frame_poses_`映射中，然后存的键是时间对的结束时间，
- 将初始位姿添加到轨迹容`trajectory_`中，初始化假设静止，`T_wc_curr = Sophus::SE3d();`初始化当前位姿为单位变换，这表示世界坐标系与当前帧坐标系重合（无旋转、无平移）
- 将初始化标志位设置为true。          


### 1.2.4 `PoseStateWithLin`结构体

- 作用：用于管理SLAM系统中位姿的线性化状态和增量更新

#### 1.2.4.1 核心设计理念

- `PoseStateWithLin` 的核心思想是分离线性化点和当前估计值：

线性化点：优化过程中固定的参考点
当前位姿：基于线性化点加上增量的实时估计值
这种设计解决了非线性优化中的关键问题：当优化变量在迭代过程中变化时，如何保持目标函数线性化的稳定性。


#### 1.2.4.2 关键成员变量
 
```cpp
bool linearized;          // 是否已线性化（标记线性化点是否已固定）
VecN delta;               // 从线性化点开始的累积增量（李代数形式）
PoseState<Scalar> pose_linearized; // 线性化时刻的位姿状态（时间戳+位姿）
SE3 T_w_i_current;       // 当前位姿（世界坐标系到当前帧坐标系）
```

#### 1.2.4.3 关键函数解析

`applyInc(const VecN& inc)` 函数

- 1. 未线性化状态,基准位姿直接更新：`pose_linearized.T_w_i` 代表当前真实位姿,增量处理：每次调用 `applyInc()` 时，增量直接应用到 `pose_linearized.T_w_i`,使用场景：初始化阶段或未加入优化问题的普通帧
- 2. 已线性化状态,基准位姿固定：`pose_linearized.T_w_i` 被冻结，不再改变,增量累积：所有增量累加到 `delta`,当前位姿计算：`T_w_i_current = pose_linearized.T_w_i * exp(delta)`,使用场景：已加入优化问题的关键帧

`getPose() const` 函数
```cpp
if (!linearized) {
    return pose_linearized.T_w_i;  // 直接返回基准位姿
} else {
    return T_w_i_current;          // 返回基于线性化点+增量的当前位姿
}
```

### 1.2.5 地图已初始化后

#### 1.2.5.1 先验信息设置

- 这一时间段的测量点云的先验设置为上一时间段点云从开始时刻到结束时刻的相对位姿变化 `measure->pseudoPrior = T_prior;`
- 预测这一时间段点云结束时刻的位姿 `Sophus::SE3d T_w_pred = frame_poses_[tp.first].getPose() * T_prior;`，开始时刻的位姿乘相对位姿变化
- 设置初始位姿初始猜想值：`frame_poses_[tp.second] =PoseStateWithLin<double>(tp.second, T_w_pred);`//未线性化，非线性优化需要有一个良好的初始值猜想，才能够更快地收敛下去。

#### 1.2.5.2 点云降采样

- `map_->PreProcess(points, tp);`函数

#### 1.2.5.3 运动状态判断

- 判断是否已离开初始位置（平移距离>0.5m），防止在初始位置微小抖动导致地图初始化失败

```cpp
if (!isMove_) {//判断是否远离初始点
            isMove_ = (T_w_pred).translation().norm() > 0.5;
          } else {
            map_->ComputeThreshold();//根据误差来动态计算配准阈值
          }
```

- 动态阈值计算：一旦开始移动，根据当前配准误差动态调整配准阈值，使系统对不同运动状态有自适应能力

   计算当前模型误差：`model_deviation_` ：上一时间段的预测与实际偏差,这个偏差反映了运动模型的准确性
   
   运动显著性过滤：当机器人几乎静止时，微小的测量噪声可能导致较大的相对误差,这些样本不能反映真实的模型精度,只有当运动足够大时（超过min_motion_th_），才认为误差样本是有效的
   
   动态阈值计算：计算历史模型误差的均方根（RMS）,这是统计学中衡量误差大小的标准方法,核心思想：阈值应该与系统的历史表现相匹配


#### 1.2.5.4 优化 `Optimize()`

- 绝对顺序映射构建，为每个位姿变量创建索引映射，将离散的位姿转换为连续的优化变量。假设有N个位姿，则优化变量维度为6N，根据索引来确定优化的是哪个变量
- 迭代优化循环
初始化全局Hessian矩阵、梯度向量；


























# 2. 论文阅读

## 概念定义


## 雅可比矩阵推导
在高斯-牛顿框架下，线性化得到 $E \approx (e + J\xi)^{\top} W^{-1} (e + J\xi)$ ，并形成正规方程 $H\xi=-b$ ，
其中 $H=J^{\!\top}W^{-1}J, b=J^{\!\top}W^{-1}e$ 。
根据这几个式子，我们要求的是增量向量 $\xi$（把所有控制位姿的 6D 增量堆叠而成，维度是 $6(K+1)$。步骤是：
- 用当前线性化点 $s=[T_0,\dots,T_K]$ 计算误差 $e$ 与雅可比 $J$ ，装配 $H,b$ ；
- 解线性方程 $H\xi=-b$（通常用稀疏 Cholesky/PCG；若 $H$ 近奇异，会用 LM 衰减 $H+\lambda I$ ；
- 将各块增量分发到位姿：$T_k \leftarrow T_k \oplus \xi_k$ ；
- 迭代重复直至收敛 $\|\|xi\|\|$ 很小或目标下降很小。

**能得到的结果：**
- 直接解出本次迭代的**最优增量** $\xi$ ；
- 由此更新得到一组更优的**控制位姿** $\{T_k\}$；
- 迭代收敛后得到整个时间窗内的**连续时间轨迹** $T(t)$ 的最优解（在当前数据与先验下的局部极小）。
同时，$H$ 体现了问题的二阶近似（信息矩阵/曲率），其稀疏块结构对应“每个误差只连少量位姿”的性质，有助于高效求解。

# Gauss–Newton 与连续时间配准项的雅可比推导（含 9a–9d, 10）


我们关注的配准误差为（点到平面）：
$$
e \;\triangleq\; \mathbf{n}^\top \Big(\, \phi_k(t_i)\,T_{LB_j}\,\mathbf{p} \;-\; \mathbf{q} \,\Big),
$$
其中 $\mathbf{n}$ 为地图局部平面法向量，$\mathbf{p}$ 是 LiDAR $j$ 坐标系下的原始点，$\mathbf{q}$ 
是地图中最近邻点（世界系）， $T_{LB_j}$ 为 LiDAR $j$ $\to$ 参考系外参， $\phi_k(t)$ 是第 $k$ 段的连续时间位姿。第 $k$ 段
内的轨迹参数化为
$$
\phi_k(t) \;=\; T_{k-1}\;\Exp\big(\alpha\,\tau^k\big),\qquad
\tau^k \;=\; \Log\!\big(T_{k-1}^{-1}T_k\big),\quad
\alpha=\tfrac{t-t_{k-1}}{\Delta t_k}.
$$

---

### 9a：链式法则的结构
误差只与当前所在段的两个控制位姿 $T_{k-1},T_k$ 有关，
因此对整堆状态 $s=[T_0,\dots,T_K]$ 的导数呈块稀疏形式。对任意线性化点 $s$ 的右扰动 $s\oplus\xi$ 做一阶展开
$$
e(s\oplus\xi)\;\approx\; e(s)\;+\;\frac{\partial e}{\partial s}\,\xi,
$$
其中
$$
\boxed{\;
\frac{\partial e}{\partial s}
\;=\;
\frac{\partial e}{\partial \phi_k(t_i)}
\;\Big[\;
\frac{\partial \phi_k(t_i)}{\partial T_{k-1}}
\quad
\frac{\partial \phi_k(t_i)}{\partial T_k}
\;\Big]
\;}
\tag{9a}
$$

这就是文中的 9a：先对中间量 $\phi_k(t_i)$ 求导（“几何项”），再乘上 $\phi_k$ 对端点位姿的导数（“插值项”）。

---

### 9b： $\displaystyle \frac{\partial e}{\partial \phi_k(t_i)}$ 的推导（几何项）
令
$$
\mathbf{X}\;\triangleq\; T_{LB_j}\,\mathbf{p}, \qquad
\phi_k(t_i)\;=\;\begin{bmatrix}R & \mathbf{t}\\ \mathbf{0}^\top & 1\end{bmatrix},
\qquad
\mathbf{x} \;\triangleq\; R\,\mathbf{X}+\mathbf{t},
$$
则
$$
e \;=\; \mathbf{n}^\top(\mathbf{x}-\mathbf{q}) \;=\; \mathbf{n}^\top(R\,\mathbf{X}+\mathbf{t}-\mathbf{q}).
$$
对位姿采用**右扰动** 
$\phi \mapsto \phi\Exp(\boldsymbol{\xi})$ ，
其中 $\boldsymbol{\xi}=[\boldsymbol{\rho};\boldsymbol{\theta}]\in\mathbb{R}^6$（先平移后旋转的右平凡化），
有一阶近似：
$$
\delta \mathbf{x}
=
\underbrace{R}_{3\times3}\,\boldsymbol{\rho}
\;-\;
\underbrace{R[\mathbf{X}]_\times}_{3\times3}\,\boldsymbol{\theta},
\quad
[\cdot]_\times \text{ 为反对称矩阵}.
$$
因此
$$
\delta e
=
\mathbf{n}^\top\,\delta \mathbf{x}
=
\mathbf{n}^\top\Big( R\,\boldsymbol{\rho} - R[\mathbf{X}]_\times \boldsymbol{\theta}\Big)
=
\underbrace{\mathbf{n}^\top\!\Big[\; R \;\; -R[\mathbf{X}]_\times \;\Big]}_{1\times 6}
\begin{bmatrix}\boldsymbol{\rho}\\ \boldsymbol{\theta}\end{bmatrix}.
$$
于是得到
$$
\boxed{\;
\frac{\partial e}{\partial \phi_k(t_i)}
\;=\;
\mathbf{n}^\top\!\Big[\; R \;\; -R\,[T_{LB_j}\mathbf{p}]_\times \;\Big]
\;}
\tag{9b}
$$
与文中写法一致（他们将 \(\mathbf{n}\) 记作 \(k n_i^j\)，并用 \(R_{k t_i^j}\) 指代 \(R\)）。

---

### 9c / 9d： $\displaystyle \frac{\partial \phi_k(t_i)}{\partial T_{k-1}},\;\frac{\partial \phi_k(t_i)}{\partial T_k}$ 的推导（插值项）
记
$$
\phi_k(t)
=
T_{k-1}\;\Exp(\alpha\,\tau),\qquad \tau=\Log(T_{k-1}^{-1}T_k).
$$
对右扰动 $\delta T_{k-1}=T_{k-1}\Exp(\boldsymbol{\xi}_{k-1})$、$\delta T_k=T_k\Exp(\boldsymbol{\xi}_k)$ 求 $\delta\phi$ 的一阶变化。需要三条李群/李代数恒等式（右/左雅可比参见 [33]）：

1. **指数映射的右雅可比微分**（在右平凡化下）  
   $$
   \delta\Exp(\alpha\tau)
   \;\approx\;
   \Exp(\alpha\tau)\;\Jr(\alpha\tau)\,\alpha\,\delta\tau.
   $$
2. **相对位姿的对数微分**  
   $$
   \delta\tau
   \;\approx\;
   \Jl(\tau)^{-1}\big(\,\boldsymbol{\xi}_k \;-\; \boldsymbol{\xi}_{k-1}\,\big).
   $$
   > 这是 $\tau=\Log(T_{k-1}^{-1}T_k)$ 在**右扰动**下的标准一阶近似：前后端点的右扰动在切空间中以 $\Jl(\tau)^{-1}$ 规整。
3. **左乘的扰动传播**  
   $$
   \delta\phi
   \;=\;
   \underbrace{T_{k-1}\Exp(\alpha\tau)}_{\phi}\,\boldsymbol{\xi}_{k-1}
   \;+\;
   T_{k-1}\,\delta\Exp(\alpha\tau).
   $$
 
把 1–3 代入并收集 $\boldsymbol{\xi}_{k-1}$ 、$\boldsymbol{\xi}_{k}$ 的系数，可写成右平凡化的增量映射
$$
\delta\phi
\;\equiv\;
\phi\,\Big(
(1-\alpha)\,\Jr\!\big((\alpha-1)\tau\big)\,\Jl(\tau)^{-1}\,\boldsymbol{\xi}_{k-1}
\;+\;
\alpha\,\Jr(\alpha\tau)\,\Jr(\tau)^{-1}\,\boldsymbol{\xi}_{k}
\Big),
$$
从而得到对端点位姿的“右雅可比”（去掉前面的 $\phi$ 左乘，因为后续会与 9b 的 $\partial e/\partial\phi$ 相乘）：

$$
\boxed{\;
\frac{\partial \phi_k(t_i)}{\partial T_{k-1}}
=
(1-\alpha)\,\Jr\!\big((\alpha-1)\tau\big)\,\Jl(\tau)^{-1}
\;}
\tag{9c}
$$

$$
\boxed{\;
\frac{\partial \phi_k(t_i)}{\partial T_{k}}
=
\alpha\,\Jr(\alpha\tau)\,\Jr(\tau)^{-1}
\;}
\tag{9d}
$$

这与文中 9c、9d 完全一致。直观理解：$(1-\alpha)$ 与 $\alpha$ 分别给出“靠近起点/终点”的权重，$\Jr,\Jl$ 则负责把端点位姿的右扰动正确地搬运到中间时刻的 $\phi_k(t_i)$ 上。

---

### 10：运动学（平滑性）约束的雅可比
平滑性误差定义为
$$
e^v_k \;=\; (T_k \ominus T_{k-1}) \;-\; \widehat{(T_{k-1}\ominus T_{k-2})}
\;=\; \tau^k \;-\; \hat{\tau}^{k-1},
$$
其中 $\tau^k=\Log(T_{k-1}^{-1}T_k)$ ，$\hat{\tau}^{k-1}$ 为上个窗口固定先验。对端点右扰动求导（用上面的第 2 条恒等式）：
$$
\boxed{\;
\frac{\partial e^v_k}{\partial T_{k-1}} = -\,\Jl(\tau^k)^{-1},
\qquad
\frac{\partial e^v_k}{\partial T_{k}} \;=\; \Jr(\tau^k)^{-1}.
\;}
\tag{10}
$$
这与文中式 (10) 一致。

---

### 小结：9a–9d 如何拼成最终雅可比
- 先用 **9b** 得到几何项 $\partial e/\partial\phi$；
- 再用 **9c、9d** 把 $\phi$ 对端点位姿的导数连锁到 $\partial e/\partial T_{k-1},\partial e/\partial T_k$；
- 将两者按 **9a** 链式相乘，装配到整堆状态 $s$ 的雅可比行中（其他不相干位姿的列为零）。
这样即可形成稀疏的 $J$，进一步构造 $H=J^\top W^{-1}J$、$b=J^\top W^{-1}e$，进入 Gauss–Newton 的线性求解与迭代更新。


---
