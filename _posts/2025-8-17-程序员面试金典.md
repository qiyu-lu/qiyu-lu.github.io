---
title: "力扣程序员面试金典刷题"
date: 2025-08-17 
categories: [算法]
tags: [算法, 力扣]
---

这是力扣中《程序员面试金典》一书中的刷题记录

# 1. 数组与字符串

## 1.1 判定字符是否唯一

### 1.1.1 暴力解法

- 对字符串中的每个字符进行遍历判断
```cpp
class Solution {
public:
    bool isUnique(string astr) {
        for(int i = 0; i < astr.size(); i++){
            for(int j = i + 1; j < astr.size(); j++){
                if(astr[i] == astr[j]) return false;
            }
        }
        return true;
    }
};
```
### 1.1.2 利用二进制编码进行求解，位运算

#### 1.1.2.1 我的算法

可以利用二进制编码进行解决这道题，使用一串二进制数的不同位置的数来表示字符串中的的不同字符，
遍历这个字符串，如果第一次见到这个字符，就在对应的位上做一个标记（**置1**），
然后如果继续遍历又发现了这个位置代表的字符，

举例子
- 设一个变量来存储字符，初始值为 ：0x00000
- 遇到a了，1左移1位 变为 0x00001，0x00001 再 与 0x00000 进行或运算得到 0x00001
- 遇到b了，1左移2位 变为 0x00010，与上面的结果 0x00001 进行或 的到 0x00011
这就是不同的位代表不同的字符，然后就是遇到相同的字符的判断
- 又遇到a了，1左移1位得 0x00001，进行或操作 结果不变，0x00011，然后如果不变说明就是
遇到了相同的字符了，判断是否发生变化可以使用异或，如果结果不变相同异或为0，不同异或不为0

通过下面这句命令可以查询ASCII的字符的十进制表示
```bash
man ascii
```
`a` 是97

题目中已经说了，s[i]仅包含小写字母，而小写字母有 26 个，那么int型完全可以存储
```cpp
class Solution {
public:
    bool isUnique(string astr) {
        if(astr.size() == 0) return true;
        int x = 0;
        for(int i = 0; i < astr.size(); ++i){
            int temp = 1 << (astr[i] - 97);
            if( (x | temp) ^ x) x = x|temp;
            else return false; 
        }
        return true;
    }
};
```
#### 1.1.2.2 其他类似的思路

首先我们可以看出来给定的字符串都是小写字母，共26个即26个状态，int类型足以存放这26个状态

- 通过 `&` 操作，我们可以去判断某个状态我们是否做过标记
- 例：`x & (1 << 0)` 判断第一个状态是否已经做过标记，若做过标记，说明状态重复，返回false

- 通过 `|` 操作，我们可以去给某个状态做标记
- 例：`x | (1 << 0)` 给第一个状态做标记

我是采用异或，略显得麻烦

```cpp
class Solution {
public:
    bool isUnique(string astr) {
        int x = 0;
        for(int i = 0; i < astr.size(); i++) {
            if(x & (1 << (astr[i] - 'a'))) return false;
            else x |= (1 << (astr[i] - 'a'));
        }
        return true;
    }
};
```